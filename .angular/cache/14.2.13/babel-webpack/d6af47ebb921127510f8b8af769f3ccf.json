{"ast":null,"code":"import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, BehaviorSubject, isObservable, throwError, timer } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n/**\r\n * Injection token of logger config\r\n */\n\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\nclass NGXLoggerConfigEngine {\n  constructor(config) {\n    this.config = this._clone(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n\n\n  get level() {\n    return this.config.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n\n\n  get serverLogLevel() {\n    return this.config.serverLogLevel;\n  }\n\n  updateConfig(config) {\n    this.config = this._clone(config);\n  }\n  /** Update the config partially\r\n   * This is useful if you want to update only one parameter of the config\r\n   */\n\n\n  partialUpdateConfig(partialConfig) {\n    // avoid any error if the config is incorrect\n    if (!partialConfig) {\n      return;\n    }\n\n    Object.keys(partialConfig).forEach(configParamKey => {\n      this.config[configParamKey] = partialConfig[configParamKey];\n    });\n  }\n\n  getConfig() {\n    return this._clone(this.config);\n  } // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\n\n\n  _clone(object) {\n    const cloneConfig = {\n      level: null\n    };\n    Object.keys(object).forEach(key => {\n      cloneConfig[key] = object[key];\n    });\n    return cloneConfig;\n  }\n\n}\n/**\r\n * Injection token of logger config engine factory\r\n */\n\n\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\n\nclass NGXLoggerConfigEngineFactory {\n  provideConfigEngine(config) {\n    return new NGXLoggerConfigEngine(config);\n  }\n\n}\n/**\r\n * Injection token of logger mapper service\r\n */\n\n\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n    /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\n\n    this.sourceMapCache = new Map();\n    /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\n\n    this.logPositionCache = new Map();\n  }\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config\r\n   * @param metadata\r\n   * @returns\r\n   */\n\n\n  getLogPosition(config, metadata) {\n    const stackLine = this.getStackLine(config); // if we were not able to parse the stackLine, just return an empty Log Position\n\n    if (!stackLine) {\n      return of({\n        fileName: '',\n        lineNumber: 0,\n        columnNumber: 0\n      });\n    }\n\n    const logPosition = this.getLocalPosition(stackLine);\n\n    if (!config.enableSourceMaps) {\n      return of(logPosition);\n    }\n\n    const sourceMapLocation = this.getSourceMapLocation(stackLine);\n    return this.getSourceMap(sourceMapLocation, logPosition);\n  }\n  /**\r\n   * Get the stackline of the original caller\r\n   * @param config\r\n   * @returns null if stackline was not found\r\n   */\n\n\n  getStackLine(config) {\n    const error = new Error();\n\n    try {\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n      try {\n        // Here are different examples of stacktrace \n        // Firefox (last line is the user code, the 4 first are ours):\n        // getStackLine@http://localhost:4200/main.js:358:23\n        // getCallerDetails@http://localhost:4200/main.js:557:44\n        // _log@http://localhost:4200/main.js:830:28\n        // debug@http://localhost:4200/main.js:652:14\n        // handleLog@http://localhost:4200/main.js:1158:29\n        // Chrome and Edge (last line is the user code):\n        // Error\n        // at Function.getStackLine (ngx-logger.js:329)\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\n        // at NGXLogger._log (ngx-logger.js:801)\n        // at NGXLogger.info (ngx-logger.js:631)\n        // at AppComponent.handleLog (app.component.ts:38)\n        let defaultProxy = 4; // We make 4 functions call before getting here\n\n        const firstStackLine = error.stack.split('\\n')[0];\n\n        if (!firstStackLine.includes('.js:')) {\n          // The stacktrace starts with no function call (example in Chrome or Edge)\n          defaultProxy = defaultProxy + 1;\n        }\n\n        return error.stack.split('\\n')[defaultProxy + (config.proxiedSteps || 0)];\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n  /**\r\n   * Get position of caller without using sourceMaps\r\n   * @param stackLine\r\n   * @returns\r\n   */\n\n\n  getLocalPosition(stackLine) {\n    // strip base path, then parse filename, line, and column, stackline looks like this :\n    // Firefox\n    // handleLog@http://localhost:4200/main.js:1158:29\n    // Chrome and Edge\n    // at AppComponent.handleLog (app.component.ts:38)\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\n    let positionEndIndex = stackLine.indexOf(')');\n\n    if (positionEndIndex < 0) {\n      positionEndIndex = undefined;\n    }\n\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\n    const dataArray = position.split(':');\n\n    if (dataArray.length === 3) {\n      return {\n        fileName: dataArray[0],\n        lineNumber: +dataArray[1],\n        columnNumber: +dataArray[2]\n      };\n    }\n\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n\n  getTranspileLocation(stackLine) {\n    // Example stackLine:\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\n    let locationStartIndex = stackLine.indexOf('(');\n\n    if (locationStartIndex < 0) {\n      locationStartIndex = stackLine.lastIndexOf('@');\n\n      if (locationStartIndex < 0) {\n        locationStartIndex = stackLine.lastIndexOf(' ');\n      }\n    }\n\n    let locationEndIndex = stackLine.indexOf(')');\n\n    if (locationEndIndex < 0) {\n      locationEndIndex = undefined;\n    }\n\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\n  }\n  /**\r\n   * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n   * @param stackLine\r\n   * @returns\r\n   */\n\n\n  getSourceMapLocation(stackLine) {\n    const file = this.getTranspileLocation(stackLine);\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\n  }\n\n  getMapping(sourceMap, position) {\n    // => ';' indicates end of a line\n    // => ',' separates mappings in a line\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n    let sourceFileIndex = 0,\n        // second field\n    sourceCodeLine = 0,\n        // third field\n    sourceCodeColumn = 0; // fourth field\n\n    const lines = sourceMap.mappings.split(';');\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      // reset column position to 0 after each line\n      let generatedCodeColumn = 0; // decode sections in line\n\n      const columns = lines[lineIndex].split(',');\n\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n        const decodedSection = vlq.decode(columns[columnIndex]);\n\n        if (decodedSection.length >= 4) {\n          // update relative positions\n          generatedCodeColumn += decodedSection[0];\n          sourceFileIndex += decodedSection[1];\n          sourceCodeLine += decodedSection[2];\n          sourceCodeColumn += decodedSection[3];\n        } // check if matching map\n\n\n        if (lineIndex === position.lineNumber) {\n          if (generatedCodeColumn === position.columnNumber) {\n            // matching column and line found\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: sourceCodeColumn\n            };\n          } else if (columnIndex + 1 === columns.length) {\n            // matching column not found, but line is correct\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: 0\n            };\n          }\n        }\n      }\n    } // failed if reached\n\n\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\n\n\n  getSourceMap(sourceMapLocation, distPosition) {\n    const req = new HttpRequest('GET', sourceMapLocation);\n    const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`; // if the specific log position is already in cache return it\n\n    if (this.logPositionCache.has(distPositionKey)) {\n      return this.logPositionCache.get(distPositionKey);\n    } // otherwise check if the source map is already cached for given source map location\n\n\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\n      if (!this.httpBackend) {\n        console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\n        this.sourceMapCache.set(sourceMapLocation, of(null));\n      } else {\n        // obtain the source map if not cached\n        this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body), retry(3), shareReplay(1)));\n      }\n    } // at this point the source map is cached, use it to get specific log position mapping\n\n\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map(sourceMap => {\n      // sourceMap can be null if HttpBackend is not provided for example\n      if (!sourceMap) {\n        return distPosition;\n      } // map generated position to source position\n\n\n      return this.getMapping(sourceMap, distPosition);\n    }), catchError(() => of(distPosition)), shareReplay(1)); // store specific log position in cache for given dest position and return it\n\n    this.logPositionCache.set(distPositionKey, logPosition$);\n    return logPosition$;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMapperService.ɵfac = function NGXLoggerMapperService_Factory(t) {\n  return new (t || NGXLoggerMapperService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMapperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMapperService,\n  factory: NGXLoggerMapperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMapperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger metadata service\r\n */\n\n\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\n  constructor(datePipe) {\n    this.datePipe = datePipe;\n  }\n\n  computeTimestamp(config) {\n    const defaultTimestamp = () => new Date().toISOString();\n\n    if (config.timestampFormat) {\n      if (!this.datePipe) {\n        console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\n        return defaultTimestamp();\n      } else {\n        return this.datePipe.transform(new Date(), config.timestampFormat);\n      }\n    }\n\n    return defaultTimestamp();\n  }\n\n  getMetadata(level, config, message, additional) {\n    const metadata = {\n      level: level,\n      additional: additional\n    }; // The user can send a function\n    // This is useful in order to compute string concatenation only when the log will actually be written\n\n    if (message && typeof message === 'function') {\n      metadata.message = message();\n    } else {\n      metadata.message = message;\n    }\n\n    metadata.timestamp = this.computeTimestamp(config);\n    return metadata;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMetadataService.ɵfac = function NGXLoggerMetadataService_Factory(t) {\n  return new (t || NGXLoggerMetadataService)(i0.ɵɵinject(i1$1.DatePipe, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMetadataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMetadataService,\n  factory: NGXLoggerMetadataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMetadataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1$1.DatePipe,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})(); // I kept this class alive only to avoid a breaking change with the old version\n// This class does not implement anything so it is useless and the interface is enough\n\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\n\n\nclass NGXLoggerMonitor {}\n/**\r\n * Injection token of logger metadata service\r\n */\n\n\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\n  shouldCallWriter(level, config, message, additional) {\n    return !config.disableConsoleLogging && level >= config.level;\n  }\n\n  shouldCallServer(level, config, message, additional) {\n    return !!config.serverLoggingUrl && level >= config.serverLogLevel;\n  }\n\n  shouldCallMonitor(level, config, message, additional) {\n    // The default behavior is to call the monitor only if the writer or the server is called\n    return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerRulesService.ɵfac = function NGXLoggerRulesService_Factory(t) {\n  return new (t || NGXLoggerRulesService)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerRulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerRulesService,\n  factory: NGXLoggerRulesService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerRulesService, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * Injection token of logger server service\r\n */\n\n\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\n  constructor(httpBackend, ngZone) {\n    this.httpBackend = httpBackend;\n    this.ngZone = ngZone;\n    this.serverCallsQueue = [];\n    this.flushingQueue = new BehaviorSubject(false);\n  }\n\n  ngOnDestroy() {\n    if (this.flushingQueue) {\n      this.flushingQueue.complete();\n      this.flushingQueue = null;\n    }\n\n    if (this.addToQueueTimer) {\n      this.addToQueueTimer.unsubscribe();\n      this.addToQueueTimer = null;\n    }\n  }\n  /**\r\n   * Transforms an error object into a readable string (taking only the stack)\r\n   * This is needed because JSON.stringify would return \"{}\"\r\n   * @param err the error object\r\n   * @returns The stack of the error\r\n   */\n\n\n  secureErrorObject(err) {\n    return err?.stack;\n  }\n  /**\r\n   * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n   * Basically it just replaces unstringifiable object to a string mentioning an error\r\n   * @param additional The additional data to be sent\r\n   * @returns The additional data secured\r\n   */\n\n\n  secureAdditionalParameters(additional) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n\n    return additional.map((next, idx) => {\n      try {\n        if (next instanceof Error) {\n          return this.secureErrorObject(next);\n        } // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n\n\n        if (typeof next === 'object') {\n          JSON.stringify(next);\n        }\n\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\n      }\n    });\n  }\n  /**\r\n   * Transforms the message so that it can be sent to the server\r\n   * @param message the message to be sent\r\n   * @returns the message secured\r\n   */\n\n\n  secureMessage(message) {\n    try {\n      if (message instanceof Error) {\n        return this.secureErrorObject(message);\n      }\n\n      if (typeof message !== 'string') {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n\n    return message;\n  }\n  /**\r\n   * Edits HttpRequest object before sending request to server\r\n   * @param httpRequest default request object\r\n   * @returns altered httprequest\r\n   */\n\n\n  alterHttpRequest(httpRequest) {\n    return httpRequest;\n  }\n  /**\r\n   * Sends request to server\r\n   * @param url\r\n   * @param logContent\r\n   * @param options\r\n   * @returns\r\n   */\n\n\n  logOnServer(url, logContent, options) {\n    if (!this.httpBackend) {\n      console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\n      return of(null);\n    } // HttpBackend skips all HttpInterceptors\n    // They may log errors using this service causing circular calls\n\n\n    let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\n    let finalRequest = of(defaultRequest);\n    const alteredRequest = this.alterHttpRequest(defaultRequest);\n\n    if (isObservable(alteredRequest)) {\n      finalRequest = alteredRequest;\n    } else if (alteredRequest) {\n      finalRequest = of(alteredRequest);\n    } else {\n      console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\n    }\n\n    return finalRequest.pipe(concatMap(req => {\n      if (!req) {\n        console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\n        return this.httpBackend.handle(defaultRequest);\n      }\n\n      return this.httpBackend.handle(req);\n    }), filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body));\n  }\n  /**\r\n   * Customise the data sent to the API\r\n   * @param metadata the data provided by NGXLogger\r\n   * @returns the data that will be sent to the API in the body\r\n   */\n\n\n  customiseRequestBody(metadata) {\n    // In our API the body is not customised\n    return metadata;\n  }\n  /**\r\n   * Flush the queue of the logger\r\n   * @param config\r\n   */\n\n\n  flushQueue(config) {\n    this.flushingQueue.next(true); // If a timer was set, we cancel it because the queue is flushed\n\n    if (this.addToQueueTimer) {\n      this.addToQueueTimer.unsubscribe();\n      this.addToQueueTimer = null;\n    }\n\n    if (!!this.serverCallsQueue && this.serverCallsQueue.length > 0) {\n      this.sendToServerAction(this.serverCallsQueue, config);\n    }\n\n    this.serverCallsQueue = [];\n    this.flushingQueue.next(false);\n  }\n\n  sendToServerAction(metadata, config) {\n    let requestBody;\n\n    const secureMetadata = pMetadata => {\n      // Copying metadata locally because we don't want to change the object for the caller\n      const securedMetadata = { ...pMetadata\n      };\n      securedMetadata.additional = this.secureAdditionalParameters(securedMetadata.additional);\n      securedMetadata.message = this.secureMessage(securedMetadata.message);\n      return securedMetadata;\n    };\n\n    if (Array.isArray(metadata)) {\n      requestBody = [];\n      metadata.forEach(m => {\n        requestBody.push(secureMetadata(m));\n      });\n    } else {\n      requestBody = secureMetadata(metadata);\n    } // Allow users to customise the data sent to the API\n\n\n    requestBody = this.customiseRequestBody(requestBody);\n    const headers = config.customHttpHeaders || new HttpHeaders();\n\n    if (!headers.has('Content-Type')) {\n      headers.set('Content-Type', 'application/json');\n    }\n\n    const logOnServerAction = () => {\n      this.logOnServer(config.serverLoggingUrl, requestBody, {\n        headers,\n        params: config.customHttpParams || new HttpParams(),\n        responseType: config.httpResponseType || 'json',\n        withCredentials: config.withCredentials || false\n      }).pipe(catchError(err => {\n        // Do not use NGXLogger here because this could cause an infinite loop \n        console.error('NGXLogger: Failed to log on server', err);\n        return throwError(err);\n      })).subscribe();\n    };\n\n    if (config.serverCallsOutsideNgZone === true) {\n      if (!this.ngZone) {\n        console.error('NGXLogger: NgZone is not provided and serverCallsOutsideNgZone is set to true');\n        return;\n      }\n\n      this.ngZone.runOutsideAngular(logOnServerAction);\n    } else {\n      logOnServerAction();\n    }\n  }\n  /**\r\n   * Sends the content to be logged to the server according to the config\r\n   * @param metadata\r\n   * @param config\r\n   */\n\n\n  sendToServer(metadata, config) {\n    // If there is no batch mode in the config, we send the log call straight to the server as usual\n    if ((!config.serverCallsBatchSize || config.serverCallsBatchSize <= 0) && (!config.serverCallsTimer || config.serverCallsTimer <= 0)) {\n      this.sendToServerAction(metadata, config);\n      return;\n    }\n\n    const addLogToQueueAction = () => {\n      this.serverCallsQueue.push({ ...metadata\n      }); // Flush queue when size is reached\n\n      if (!!config.serverCallsBatchSize && this.serverCallsQueue.length > config.serverCallsBatchSize) {\n        this.flushQueue(config);\n      } // Call timer only if it is in the config and timer is not already running\n\n\n      if (config.serverCallsTimer > 0 && !this.addToQueueTimer) {\n        this.addToQueueTimer = timer(config.serverCallsTimer).subscribe(_ => {\n          this.flushQueue(config);\n        });\n      }\n    }; // If queue is being flushed, we need to wait for it to finish before adding other calls\n\n\n    if (this.flushingQueue.value === true) {\n      this.flushingQueue.pipe(filter(fq => fq === false), take(1)).subscribe(_ => {\n        addLogToQueueAction();\n      });\n    } else {\n      addLogToQueueAction();\n    }\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerServerService.ɵfac = function NGXLoggerServerService_Factory(t) {\n  return new (t || NGXLoggerServerService)(i0.ɵɵinject(i1.HttpBackend, 8), i0.ɵɵinject(i0.NgZone, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerServerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerServerService,\n  factory: NGXLoggerServerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: i0.NgZone,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger writer service\r\n */\n\n\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\nvar NgxLoggerLevel;\n\n(function (NgxLoggerLevel) {\n  NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\n  NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\n  NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\n  NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\n  NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\n  NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = ['purple', 'teal', 'gray', 'gray', 'red', 'red', 'red'];\n\nclass NGXLoggerWriterService {\n  constructor(platformId) {\n    this.platformId = platformId;\n    /** List of functions called when preparing meta string */\n\n    this.prepareMetaStringFuncs = [this.getTimestampToWrite, this.getLevelToWrite, this.getFileDetailsToWrite, this.getContextToWrite];\n    this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent && !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n    this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\n  }\n\n  getTimestampToWrite(metadata, config) {\n    return metadata.timestamp;\n  }\n\n  getLevelToWrite(metadata, config) {\n    return NgxLoggerLevel[metadata.level];\n  }\n\n  getFileDetailsToWrite(metadata, config) {\n    return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\n  }\n\n  getContextToWrite(metadata, config) {\n    return config.context ? `{${config.context}}` : '';\n  }\n  /** Generate a \"meta\" string that is displayed before the content sent to the log function */\n\n\n  prepareMetaString(metadata, config) {\n    let metaString = '';\n    this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\n      const metaItem = prepareMetaStringFunc(metadata, config);\n\n      if (metaItem) {\n        metaString = metaString + ' ' + metaItem;\n      }\n    });\n    return metaString.trim();\n  }\n  /** Get the color to use when writing to console */\n\n\n  getColor(metadata, config) {\n    const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME; // this is needed to avoid a build error\n\n    if (metadata.level === NgxLoggerLevel.OFF) {\n      return undefined;\n    }\n\n    return configColorScheme[metadata.level];\n  }\n  /** Log to the console specifically for IE */\n\n\n  logIE(metadata, config, metaString) {\n    // Coloring doesn't work in IE\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      default:\n        console.log(`${metaString} `, metadata.message, ...additional);\n    }\n  }\n  /** Log to the console */\n\n\n  logModern(metadata, config, metaString) {\n    const color = this.getColor(metadata, config); // make sure additional isn't null or undefined so that ...additional doesn't error\n\n    const additional = metadata.additional || [];\n\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.INFO:\n        console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\n      // the console.trace statement\n      // case NgxLoggerLevel.TRACE:\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n\n      case NgxLoggerLevel.DEBUG:\n        console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      default:\n        console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n    }\n  }\n  /** Write the content sent to the log function to the console */\n\n\n  writeMessage(metadata, config) {\n    const metaString = this.prepareMetaString(metadata, config);\n    this.logFunc(metadata, config, metaString);\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerWriterService.ɵfac = function NGXLoggerWriterService_Factory(t) {\n  return new (t || NGXLoggerWriterService)(i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerWriterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerWriterService,\n  factory: NGXLoggerWriterService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerWriterService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass NGXLogger {\n  constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n    this.configEngine = configEngineFactory.provideConfigEngine(config);\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n\n\n  get level() {\n    return this.configEngine.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n\n\n  get serverLogLevel() {\n    return this.configEngine.serverLogLevel;\n  }\n\n  trace(message, ...additional) {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n\n  debug(message, ...additional) {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n\n  info(message, ...additional) {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n\n  log(message, ...additional) {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n\n  warn(message, ...additional) {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n\n  error(message, ...additional) {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n\n  fatal(message, ...additional) {\n    this._log(NgxLoggerLevel.FATAL, message, additional);\n  }\n  /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\n\n\n  setCustomHttpHeaders(headers) {\n    const config = this.getConfigSnapshot();\n    config.customHttpHeaders = headers;\n    this.updateConfig(config);\n  }\n  /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\n\n\n  setCustomParams(params) {\n    const config = this.getConfigSnapshot();\n    config.customHttpParams = params;\n    this.updateConfig(config);\n  }\n  /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\n\n\n  setWithCredentialsOptionValue(withCredentials) {\n    const config = this.getConfigSnapshot();\n    config.withCredentials = withCredentials;\n    this.updateConfig(config);\n  }\n  /**\r\n   * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n   *\r\n   * There is only one monitor, registering one will overwrite the last one if there was one\r\n   * @param monitor\r\n   */\n\n\n  registerMonitor(monitor) {\n    this._loggerMonitor = monitor;\n  }\n  /** Set config of logger\r\n   *\r\n   * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n   */\n\n\n  updateConfig(config) {\n    this.configEngine.updateConfig(config);\n  }\n\n  partialUpdateConfig(partialConfig) {\n    this.configEngine.partialUpdateConfig(partialConfig);\n  }\n  /** Get config of logger */\n\n\n  getConfigSnapshot() {\n    return this.configEngine.getConfig();\n  }\n  /**\r\n   * Flush the serveur queue\r\n   */\n\n\n  flushServerQueue() {\n    this.serverService.flushQueue(this.getConfigSnapshot());\n  }\n\n  _log(level, message, additional = []) {\n    const config = this.configEngine.getConfig();\n    const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\n    const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\n    const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\n\n    if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\n      // If nothing is to be called we return\n      return;\n    }\n\n    const metadata = this.metadataService.getMetadata(level, config, message, additional);\n    this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\n      if (logPosition) {\n        metadata.fileName = logPosition.fileName;\n        metadata.lineNumber = logPosition.lineNumber;\n        metadata.columnNumber = logPosition.columnNumber;\n      }\n\n      if (shouldCallMonitor && this._loggerMonitor) {\n        this._loggerMonitor.onLog(metadata, config);\n      }\n\n      if (shouldCallWriter) {\n        this.writerService.writeMessage(metadata, config);\n      }\n\n      if (shouldCallServer) {\n        this.serverService.sendToServer(metadata, config);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLogger.ɵfac = function NGXLogger_Factory(t) {\n  return new (t || NGXLogger)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLogger,\n  factory: NGXLogger.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLogger, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\n\n\nclass CustomNGXLoggerService {\n  constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.logger = logger;\n    this.configEngineFactory = configEngineFactory;\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n  }\n  /**\r\n   * Create an instance of a logger\r\n   * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n   * @param config\r\n   * @param serverService\r\n   * @param logMonitor\r\n   * @param mapperService\r\n   * @returns\r\n   */\n\n\n  create(config, serverService, logMonitor, mapperService) {\n    return this.getNewInstance({\n      config,\n      serverService,\n      logMonitor,\n      mapperService\n    });\n  }\n  /**\r\n   * Get a new instance of NGXLogger\r\n   * @param params list of optional params to use when creating an instance of NGXLogger\r\n   * @returns the new instance of NGXLogger\r\n   */\n\n\n  getNewInstance(params) {\n    const logger = new NGXLogger(params?.config ?? this.logger.getConfigSnapshot(), params?.configEngineFactory ?? this.configEngineFactory, params?.metadataService ?? this.metadataService, params?.ruleService ?? this.ruleService, params?.mapperService ?? this.mapperService, params?.writerService ?? this.writerService, params?.serverService ?? this.serverService);\n\n    if (params?.partialConfig) {\n      logger.partialUpdateConfig(params.partialConfig);\n    }\n\n    if (params?.logMonitor) {\n      logger.registerMonitor(params.logMonitor);\n    }\n\n    return logger;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nCustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) {\n  return new (t || CustomNGXLoggerService)(i0.ɵɵinject(NGXLogger), i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nCustomNGXLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CustomNGXLoggerService,\n  factory: CustomNGXLoggerService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: NGXLogger\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n\nclass LoggerModule {\n  static forRoot(config, customProvider) {\n    if (!customProvider) {\n      customProvider = {};\n    } // default config provider\n\n\n    if (!customProvider.configProvider) {\n      customProvider.configProvider = {\n        provide: TOKEN_LOGGER_CONFIG,\n        useValue: config || {}\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\n        throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\n      }\n    } // default configEngine provider\n\n\n    if (!customProvider.configEngineFactoryProvider) {\n      customProvider.configEngineFactoryProvider = {\n        provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY,\n        useClass: NGXLoggerConfigEngineFactory\n      };\n    } else {\n      // if the user provided its own configEngineFactory, we just make sure the injection token is correct\n      if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\n        throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\n      }\n    } // default metadata provider\n\n\n    if (!customProvider.metadataProvider) {\n      customProvider.metadataProvider = {\n        provide: TOKEN_LOGGER_METADATA_SERVICE,\n        useClass: NGXLoggerMetadataService\n      };\n    } else {\n      // if the user provided its own metadataService, we just make sure the injection token is correct\n      if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\n        throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\n      }\n    } // default rule provider\n\n\n    if (!customProvider.ruleProvider) {\n      customProvider.ruleProvider = {\n        provide: TOKEN_LOGGER_RULES_SERVICE,\n        useClass: NGXLoggerRulesService\n      };\n    } else {\n      // if the user provided its own ruleService, we just make sure the injection token is correct\n      if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\n        throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\n      }\n    } // default mapper provider\n\n\n    if (!customProvider.mapperProvider) {\n      customProvider.mapperProvider = {\n        provide: TOKEN_LOGGER_MAPPER_SERVICE,\n        useClass: NGXLoggerMapperService\n      };\n    } else {\n      // if the user provided its own mapperService, we just make sure the injection token is correct\n      if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\n        throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\n      }\n    } // default writer provider\n\n\n    if (!customProvider.writerProvider) {\n      customProvider.writerProvider = {\n        provide: TOKEN_LOGGER_WRITER_SERVICE,\n        useClass: NGXLoggerWriterService\n      };\n    } else {\n      // if the user provided its own writerService, we just make sure the injection token is correct\n      if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\n        throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    } // default server provider\n\n\n    if (!customProvider.serverProvider) {\n      customProvider.serverProvider = {\n        provide: TOKEN_LOGGER_SERVER_SERVICE,\n        useClass: NGXLoggerServerService\n      };\n    } else {\n      // if the user provided its own serverService, we just make sure the injection token is correct\n      if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\n        throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n\n    return {\n      ngModule: LoggerModule,\n      providers: [NGXLogger, customProvider.configProvider, customProvider.configEngineFactoryProvider, customProvider.metadataProvider, customProvider.ruleProvider, customProvider.mapperProvider, customProvider.writerProvider, customProvider.serverProvider, CustomNGXLoggerService]\n    };\n  }\n\n  static forChild() {\n    // todo : this forChild is useless for now because nothing is different from forRoot.\n    // This should be implemented so that user can change the providers in the forChild\n    return {\n      ngModule: LoggerModule\n    };\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLoggerModule.ɵfac = function LoggerModule_Factory(t) {\n  return new (t || LoggerModule)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLoggerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LoggerModule\n});\n/** @nocollapse */\n\n/** @nocollapse */\n\nLoggerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };","map":{"version":3,"names":["i1","HttpRequest","HttpResponse","HttpHeaders","HttpParams","i0","Injectable","Optional","PLATFORM_ID","Inject","NgModule","of","BehaviorSubject","isObservable","throwError","timer","filter","map","retry","shareReplay","catchError","concatMap","take","vlq","i1$1","isPlatformBrowser","CommonModule","TOKEN_LOGGER_CONFIG","NGXLoggerConfigEngine","constructor","config","_clone","level","serverLogLevel","updateConfig","partialUpdateConfig","partialConfig","Object","keys","forEach","configParamKey","getConfig","object","cloneConfig","key","TOKEN_LOGGER_CONFIG_ENGINE_FACTORY","NGXLoggerConfigEngineFactory","provideConfigEngine","TOKEN_LOGGER_MAPPER_SERVICE","NGXLoggerMapperService","httpBackend","sourceMapCache","Map","logPositionCache","getLogPosition","metadata","stackLine","getStackLine","fileName","lineNumber","columnNumber","logPosition","getLocalPosition","enableSourceMaps","sourceMapLocation","getSourceMapLocation","getSourceMap","error","Error","e","defaultProxy","firstStackLine","stack","split","includes","proxiedSteps","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","undefined","position","substring","dataArray","length","getTranspileLocation","locationStartIndex","locationEndIndex","file","mapFullPath","getMapping","sourceMap","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","decode","sources","distPosition","req","distPositionKey","has","get","console","set","handle","pipe","httpResponse","body","logPosition$","ɵfac","HttpBackend","ɵprov","type","decorators","TOKEN_LOGGER_METADATA_SERVICE","NGXLoggerMetadataService","datePipe","computeTimestamp","defaultTimestamp","Date","toISOString","timestampFormat","transform","getMetadata","message","additional","timestamp","DatePipe","NGXLoggerMonitor","TOKEN_LOGGER_RULES_SERVICE","NGXLoggerRulesService","shouldCallWriter","disableConsoleLogging","shouldCallServer","serverLoggingUrl","shouldCallMonitor","TOKEN_LOGGER_SERVER_SERVICE","NGXLoggerServerService","ngZone","serverCallsQueue","flushingQueue","ngOnDestroy","complete","addToQueueTimer","unsubscribe","secureErrorObject","err","secureAdditionalParameters","next","idx","JSON","stringify","secureMessage","alterHttpRequest","httpRequest","logOnServer","url","logContent","options","defaultRequest","finalRequest","alteredRequest","warn","customiseRequestBody","flushQueue","sendToServerAction","requestBody","secureMetadata","pMetadata","securedMetadata","Array","isArray","m","push","headers","customHttpHeaders","logOnServerAction","params","customHttpParams","responseType","httpResponseType","withCredentials","subscribe","serverCallsOutsideNgZone","runOutsideAngular","sendToServer","serverCallsBatchSize","serverCallsTimer","addLogToQueueAction","_","value","fq","NgZone","TOKEN_LOGGER_WRITER_SERVICE","NgxLoggerLevel","DEFAULT_COLOR_SCHEME","NGXLoggerWriterService","platformId","prepareMetaStringFuncs","getTimestampToWrite","getLevelToWrite","getFileDetailsToWrite","getContextToWrite","isIE","navigator","userAgent","match","logFunc","logIE","bind","logModern","disableFileDetails","context","prepareMetaString","metaString","prepareMetaStringFunc","metaItem","trim","getColor","configColorScheme","colorScheme","OFF","WARN","ERROR","FATAL","INFO","info","log","color","DEBUG","debug","writeMessage","args","NGXLogger","configEngineFactory","metadataService","ruleService","mapperService","writerService","serverService","configEngine","trace","_log","TRACE","LOG","fatal","setCustomHttpHeaders","getConfigSnapshot","setCustomParams","setWithCredentialsOptionValue","registerMonitor","monitor","_loggerMonitor","flushServerQueue","onLog","providedIn","CustomNGXLoggerService","logger","create","logMonitor","getNewInstance","LoggerModule","forRoot","customProvider","configProvider","provide","useValue","configEngineFactoryProvider","useClass","metadataProvider","ruleProvider","mapperProvider","writerProvider","serverProvider","ngModule","providers","forChild","ɵmod","ɵinj","imports"],"sources":["D:/Nueva carpeta/Shogai-internal/ultimoAhoraSi/node_modules/ngx-logger/fesm2020/ngx-logger.mjs"],"sourcesContent":["import * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, PLATFORM_ID, Inject, NgModule } from '@angular/core';\nimport { of, BehaviorSubject, isObservable, throwError, timer } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, concatMap, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\r\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\nclass NGXLoggerConfigEngine {\r\n    constructor(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.config.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.config.serverLogLevel;\r\n    }\r\n    updateConfig(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    /** Update the config partially\r\n     * This is useful if you want to update only one parameter of the config\r\n     */\r\n    partialUpdateConfig(partialConfig) {\r\n        // avoid any error if the config is incorrect\r\n        if (!partialConfig) {\r\n            return;\r\n        }\r\n        Object.keys(partialConfig).forEach(configParamKey => {\r\n            this.config[configParamKey] = partialConfig[configParamKey];\r\n        });\r\n    }\r\n    getConfig() {\r\n        return this._clone(this.config);\r\n    }\r\n    // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\r\n    _clone(object) {\r\n        const cloneConfig = { level: null };\r\n        Object.keys(object).forEach((key) => {\r\n            cloneConfig[key] = object[key];\r\n        });\r\n        return cloneConfig;\r\n    }\r\n}\n\n/**\r\n * Injection token of logger config engine factory\r\n */\r\nconst TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\n\nclass NGXLoggerConfigEngineFactory {\r\n    provideConfigEngine(config) {\r\n        return new NGXLoggerConfigEngine(config);\r\n    }\r\n}\n\n/**\r\n * Injection token of logger mapper service\r\n */\r\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n        /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\r\n        this.sourceMapCache = new Map();\r\n        /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\r\n        this.logPositionCache = new Map();\r\n    }\r\n    /**\r\n     * Returns the log position of the caller\r\n     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n     * @param config\r\n     * @param metadata\r\n     * @returns\r\n     */\r\n    getLogPosition(config, metadata) {\r\n        const stackLine = this.getStackLine(config);\r\n        // if we were not able to parse the stackLine, just return an empty Log Position\r\n        if (!stackLine) {\r\n            return of({ fileName: '', lineNumber: 0, columnNumber: 0 });\r\n        }\r\n        const logPosition = this.getLocalPosition(stackLine);\r\n        if (!config.enableSourceMaps) {\r\n            return of(logPosition);\r\n        }\r\n        const sourceMapLocation = this.getSourceMapLocation(stackLine);\r\n        return this.getSourceMap(sourceMapLocation, logPosition);\r\n    }\r\n    /**\r\n     * Get the stackline of the original caller\r\n     * @param config\r\n     * @returns null if stackline was not found\r\n     */\r\n    getStackLine(config) {\r\n        const error = new Error();\r\n        try {\r\n            // noinspection ExceptionCaughtLocallyJS\r\n            throw error;\r\n        }\r\n        catch (e) {\r\n            try {\r\n                // Here are different examples of stacktrace \r\n                // Firefox (last line is the user code, the 4 first are ours):\r\n                // getStackLine@http://localhost:4200/main.js:358:23\r\n                // getCallerDetails@http://localhost:4200/main.js:557:44\r\n                // _log@http://localhost:4200/main.js:830:28\r\n                // debug@http://localhost:4200/main.js:652:14\r\n                // handleLog@http://localhost:4200/main.js:1158:29\r\n                // Chrome and Edge (last line is the user code):\r\n                // Error\r\n                // at Function.getStackLine (ngx-logger.js:329)\r\n                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n                // at NGXLogger._log (ngx-logger.js:801)\r\n                // at NGXLogger.info (ngx-logger.js:631)\r\n                // at AppComponent.handleLog (app.component.ts:38)\r\n                let defaultProxy = 4; // We make 4 functions call before getting here\r\n                const firstStackLine = error.stack.split('\\n')[0];\r\n                if (!firstStackLine.includes('.js:')) {\r\n                    // The stacktrace starts with no function call (example in Chrome or Edge)\r\n                    defaultProxy = defaultProxy + 1;\r\n                }\r\n                return error.stack.split('\\n')[(defaultProxy + (config.proxiedSteps || 0))];\r\n            }\r\n            catch (e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get position of caller without using sourceMaps\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getLocalPosition(stackLine) {\r\n        // strip base path, then parse filename, line, and column, stackline looks like this :\r\n        // Firefox\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n        // Chrome and Edge\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n        const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n        let positionEndIndex = stackLine.indexOf(')');\r\n        if (positionEndIndex < 0) {\r\n            positionEndIndex = undefined;\r\n        }\r\n        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n        const dataArray = position.split(':');\r\n        if (dataArray.length === 3) {\r\n            return { fileName: dataArray[0], lineNumber: +dataArray[1], columnNumber: +dataArray[2] };\r\n        }\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    getTranspileLocation(stackLine) {\r\n        // Example stackLine:\r\n        // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n        let locationStartIndex = stackLine.indexOf('(');\r\n        if (locationStartIndex < 0) {\r\n            locationStartIndex = stackLine.lastIndexOf('@');\r\n            if (locationStartIndex < 0) {\r\n                locationStartIndex = stackLine.lastIndexOf(' ');\r\n            }\r\n        }\r\n        let locationEndIndex = stackLine.indexOf(')');\r\n        if (locationEndIndex < 0) {\r\n            locationEndIndex = undefined;\r\n        }\r\n        return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n    }\r\n    /**\r\n     * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getSourceMapLocation(stackLine) {\r\n        const file = this.getTranspileLocation(stackLine);\r\n        const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n    }\r\n    getMapping(sourceMap, position) {\r\n        // => ';' indicates end of a line\r\n        // => ',' separates mappings in a line\r\n        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n        let sourceFileIndex = 0, // second field\r\n        sourceCodeLine = 0, // third field\r\n        sourceCodeColumn = 0; // fourth field\r\n        const lines = sourceMap.mappings.split(';');\r\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n            // reset column position to 0 after each line\r\n            let generatedCodeColumn = 0;\r\n            // decode sections in line\r\n            const columns = lines[lineIndex].split(',');\r\n            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n                const decodedSection = vlq.decode(columns[columnIndex]);\r\n                if (decodedSection.length >= 4) {\r\n                    // update relative positions\r\n                    generatedCodeColumn += decodedSection[0];\r\n                    sourceFileIndex += decodedSection[1];\r\n                    sourceCodeLine += decodedSection[2];\r\n                    sourceCodeColumn += decodedSection[3];\r\n                }\r\n                // check if matching map\r\n                if (lineIndex === position.lineNumber) {\r\n                    if (generatedCodeColumn === position.columnNumber) {\r\n                        // matching column and line found\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: sourceCodeColumn };\r\n                    }\r\n                    else if (columnIndex + 1 === columns.length) {\r\n                        // matching column not found, but line is correct\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: 0 };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // failed if reached\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    /**\r\n     * does the http get request to get the source map\r\n     * @param sourceMapLocation\r\n     * @param distPosition\r\n     */\r\n    getSourceMap(sourceMapLocation, distPosition) {\r\n        const req = new HttpRequest('GET', sourceMapLocation);\r\n        const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\r\n        // if the specific log position is already in cache return it\r\n        if (this.logPositionCache.has(distPositionKey)) {\r\n            return this.logPositionCache.get(distPositionKey);\r\n        }\r\n        // otherwise check if the source map is already cached for given source map location\r\n        if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n            if (!this.httpBackend) {\r\n                console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\r\n                this.sourceMapCache.set(sourceMapLocation, of(null));\r\n            }\r\n            else {\r\n                // obtain the source map if not cached\r\n                this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));\r\n            }\r\n        }\r\n        // at this point the source map is cached, use it to get specific log position mapping\r\n        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => {\r\n            // sourceMap can be null if HttpBackend is not provided for example\r\n            if (!sourceMap) {\r\n                return distPosition;\r\n            }\r\n            // map generated position to source position\r\n            return this.getMapping(sourceMap, distPosition);\r\n        }), catchError(() => of(distPosition)), shareReplay(1));\r\n        // store specific log position in cache for given dest position and return it\r\n        this.logPositionCache.set(distPositionKey, logPosition$);\r\n        return logPosition$;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\r\n    constructor(datePipe) {\r\n        this.datePipe = datePipe;\r\n    }\r\n    computeTimestamp(config) {\r\n        const defaultTimestamp = () => new Date().toISOString();\r\n        if (config.timestampFormat) {\r\n            if (!this.datePipe) {\r\n                console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\r\n                return defaultTimestamp();\r\n            }\r\n            else {\r\n                return this.datePipe.transform(new Date(), config.timestampFormat);\r\n            }\r\n        }\r\n        return defaultTimestamp();\r\n    }\r\n    getMetadata(level, config, message, additional) {\r\n        const metadata = {\r\n            level: level,\r\n            additional: additional,\r\n        };\r\n        // The user can send a function\r\n        // This is useful in order to compute string concatenation only when the log will actually be written\r\n        if (message && typeof message === 'function') {\r\n            metadata.message = message();\r\n        }\r\n        else {\r\n            metadata.message = message;\r\n        }\r\n        metadata.timestamp = this.computeTimestamp(config);\r\n        return metadata;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, deps: [{ token: i1$1.DatePipe, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1$1.DatePipe, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n// I kept this class alive only to avoid a breaking change with the old version\r\n// This class does not implement anything so it is useless and the interface is enough\r\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\r\nclass NGXLoggerMonitor {\r\n}\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\r\n    shouldCallWriter(level, config, message, additional) {\r\n        return !config.disableConsoleLogging && level >= config.level;\r\n    }\r\n    shouldCallServer(level, config, message, additional) {\r\n        return !!config.serverLoggingUrl && level >= config.serverLogLevel;\r\n    }\r\n    shouldCallMonitor(level, config, message, additional) {\r\n        // The default behavior is to call the monitor only if the writer or the server is called\r\n        return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Injection token of logger server service\r\n */\r\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\r\n    constructor(httpBackend, ngZone) {\r\n        this.httpBackend = httpBackend;\r\n        this.ngZone = ngZone;\r\n        this.serverCallsQueue = [];\r\n        this.flushingQueue = new BehaviorSubject(false);\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.flushingQueue) {\r\n            this.flushingQueue.complete();\r\n            this.flushingQueue = null;\r\n        }\r\n        if (this.addToQueueTimer) {\r\n            this.addToQueueTimer.unsubscribe();\r\n            this.addToQueueTimer = null;\r\n        }\r\n    }\r\n    /**\r\n     * Transforms an error object into a readable string (taking only the stack)\r\n     * This is needed because JSON.stringify would return \"{}\"\r\n     * @param err the error object\r\n     * @returns The stack of the error\r\n     */\r\n    secureErrorObject(err) {\r\n        return err?.stack;\r\n    }\r\n    /**\r\n     * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n     * Basically it just replaces unstringifiable object to a string mentioning an error\r\n     * @param additional The additional data to be sent\r\n     * @returns The additional data secured\r\n     */\r\n    secureAdditionalParameters(additional) {\r\n        if (additional === null || additional === undefined) {\r\n            return null;\r\n        }\r\n        return additional.map((next, idx) => {\r\n            try {\r\n                if (next instanceof Error) {\r\n                    return this.secureErrorObject(next);\r\n                }\r\n                // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n                if (typeof next === 'object') {\r\n                    JSON.stringify(next);\r\n                }\r\n                return next;\r\n            }\r\n            catch (e) {\r\n                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Transforms the message so that it can be sent to the server\r\n     * @param message the message to be sent\r\n     * @returns the message secured\r\n     */\r\n    secureMessage(message) {\r\n        try {\r\n            if (message instanceof Error) {\r\n                return this.secureErrorObject(message);\r\n            }\r\n            if (typeof message !== 'string') {\r\n                message = JSON.stringify(message, null, 2);\r\n            }\r\n        }\r\n        catch (e) {\r\n            message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n        }\r\n        return message;\r\n    }\r\n    /**\r\n     * Edits HttpRequest object before sending request to server\r\n     * @param httpRequest default request object\r\n     * @returns altered httprequest\r\n     */\r\n    alterHttpRequest(httpRequest) {\r\n        return httpRequest;\r\n    }\r\n    /**\r\n     * Sends request to server\r\n     * @param url\r\n     * @param logContent\r\n     * @param options\r\n     * @returns\r\n     */\r\n    logOnServer(url, logContent, options) {\r\n        if (!this.httpBackend) {\r\n            console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\r\n            return of(null);\r\n        }\r\n        // HttpBackend skips all HttpInterceptors\r\n        // They may log errors using this service causing circular calls\r\n        let defaultRequest = new HttpRequest('POST', url, logContent, options || {});\r\n        let finalRequest = of(defaultRequest);\r\n        const alteredRequest = this.alterHttpRequest(defaultRequest);\r\n        if (isObservable(alteredRequest)) {\r\n            finalRequest = alteredRequest;\r\n        }\r\n        else if (alteredRequest) {\r\n            finalRequest = of(alteredRequest);\r\n        }\r\n        else {\r\n            console.warn('NGXLogger : alterHttpRequest returned an invalid request. Using default one instead');\r\n        }\r\n        return finalRequest.pipe(concatMap(req => {\r\n            if (!req) {\r\n                console.warn('NGXLogger : alterHttpRequest returned an invalid request (observable). Using default one instead');\r\n                return this.httpBackend.handle(defaultRequest);\r\n            }\r\n            return this.httpBackend.handle(req);\r\n        }), filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));\r\n    }\r\n    /**\r\n     * Customise the data sent to the API\r\n     * @param metadata the data provided by NGXLogger\r\n     * @returns the data that will be sent to the API in the body\r\n     */\r\n    customiseRequestBody(metadata) {\r\n        // In our API the body is not customised\r\n        return metadata;\r\n    }\r\n    /**\r\n     * Flush the queue of the logger\r\n     * @param config\r\n     */\r\n    flushQueue(config) {\r\n        this.flushingQueue.next(true);\r\n        // If a timer was set, we cancel it because the queue is flushed\r\n        if (this.addToQueueTimer) {\r\n            this.addToQueueTimer.unsubscribe();\r\n            this.addToQueueTimer = null;\r\n        }\r\n        if (!!this.serverCallsQueue && this.serverCallsQueue.length > 0) {\r\n            this.sendToServerAction(this.serverCallsQueue, config);\r\n        }\r\n        this.serverCallsQueue = [];\r\n        this.flushingQueue.next(false);\r\n    }\r\n    sendToServerAction(metadata, config) {\r\n        let requestBody;\r\n        const secureMetadata = (pMetadata) => {\r\n            // Copying metadata locally because we don't want to change the object for the caller\r\n            const securedMetadata = { ...pMetadata };\r\n            securedMetadata.additional = this.secureAdditionalParameters(securedMetadata.additional);\r\n            securedMetadata.message = this.secureMessage(securedMetadata.message);\r\n            return securedMetadata;\r\n        };\r\n        if (Array.isArray(metadata)) {\r\n            requestBody = [];\r\n            metadata.forEach(m => {\r\n                requestBody.push(secureMetadata(m));\r\n            });\r\n        }\r\n        else {\r\n            requestBody = secureMetadata(metadata);\r\n        }\r\n        // Allow users to customise the data sent to the API\r\n        requestBody = this.customiseRequestBody(requestBody);\r\n        const headers = config.customHttpHeaders || new HttpHeaders();\r\n        if (!headers.has('Content-Type')) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n        const logOnServerAction = () => {\r\n            this.logOnServer(config.serverLoggingUrl, requestBody, {\r\n                headers,\r\n                params: config.customHttpParams || new HttpParams(),\r\n                responseType: config.httpResponseType || 'json',\r\n                withCredentials: config.withCredentials || false,\r\n            }).pipe(catchError(err => {\r\n                // Do not use NGXLogger here because this could cause an infinite loop \r\n                console.error('NGXLogger: Failed to log on server', err);\r\n                return throwError(err);\r\n            })).subscribe();\r\n        };\r\n        if (config.serverCallsOutsideNgZone === true) {\r\n            if (!this.ngZone) {\r\n                console.error('NGXLogger: NgZone is not provided and serverCallsOutsideNgZone is set to true');\r\n                return;\r\n            }\r\n            this.ngZone.runOutsideAngular(logOnServerAction);\r\n        }\r\n        else {\r\n            logOnServerAction();\r\n        }\r\n    }\r\n    /**\r\n     * Sends the content to be logged to the server according to the config\r\n     * @param metadata\r\n     * @param config\r\n     */\r\n    sendToServer(metadata, config) {\r\n        // If there is no batch mode in the config, we send the log call straight to the server as usual\r\n        if ((!config.serverCallsBatchSize || config.serverCallsBatchSize <= 0) &&\r\n            (!config.serverCallsTimer || config.serverCallsTimer <= 0)) {\r\n            this.sendToServerAction(metadata, config);\r\n            return;\r\n        }\r\n        const addLogToQueueAction = () => {\r\n            this.serverCallsQueue.push({ ...metadata });\r\n            // Flush queue when size is reached\r\n            if (!!config.serverCallsBatchSize && this.serverCallsQueue.length > config.serverCallsBatchSize) {\r\n                this.flushQueue(config);\r\n            }\r\n            // Call timer only if it is in the config and timer is not already running\r\n            if (config.serverCallsTimer > 0 && !this.addToQueueTimer) {\r\n                this.addToQueueTimer = timer(config.serverCallsTimer).subscribe(_ => {\r\n                    this.flushQueue(config);\r\n                });\r\n            }\r\n        };\r\n        // If queue is being flushed, we need to wait for it to finish before adding other calls\r\n        if (this.flushingQueue.value === true) {\r\n            this.flushingQueue.pipe(filter(fq => fq === false), take(1)).subscribe(_ => {\r\n                addLogToQueueAction();\r\n            });\r\n        }\r\n        else {\r\n            addLogToQueueAction();\r\n        }\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, deps: [{ token: i1.HttpBackend, optional: true }, { token: i0.NgZone, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1.HttpBackend, decorators: [{\r\n                    type: Optional\r\n                }] }, { type: i0.NgZone, decorators: [{\r\n                    type: Optional\r\n                }] }]; } });\n\n/**\r\n * Injection token of logger writer service\r\n */\r\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\n\nvar NgxLoggerLevel;\r\n(function (NgxLoggerLevel) {\r\n    NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\r\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = [\r\n    'purple',\r\n    'teal',\r\n    'gray',\r\n    'gray',\r\n    'red',\r\n    'red',\r\n    'red'\r\n];\n\nclass NGXLoggerWriterService {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n        /** List of functions called when preparing meta string */\r\n        this.prepareMetaStringFuncs = [\r\n            this.getTimestampToWrite,\r\n            this.getLevelToWrite,\r\n            this.getFileDetailsToWrite,\r\n            this.getContextToWrite,\r\n        ];\r\n        this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n        this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\r\n    }\r\n    getTimestampToWrite(metadata, config) {\r\n        return metadata.timestamp;\r\n    }\r\n    getLevelToWrite(metadata, config) {\r\n        return NgxLoggerLevel[metadata.level];\r\n    }\r\n    getFileDetailsToWrite(metadata, config) {\r\n        return config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\r\n    }\r\n    getContextToWrite(metadata, config) {\r\n        return config.context ? `{${config.context}}` : '';\r\n    }\r\n    /** Generate a \"meta\" string that is displayed before the content sent to the log function */\r\n    prepareMetaString(metadata, config) {\r\n        let metaString = '';\r\n        this.prepareMetaStringFuncs.forEach(prepareMetaStringFunc => {\r\n            const metaItem = prepareMetaStringFunc(metadata, config);\r\n            if (metaItem) {\r\n                metaString = metaString + ' ' + metaItem;\r\n            }\r\n        });\r\n        return metaString.trim();\r\n    }\r\n    /** Get the color to use when writing to console */\r\n    getColor(metadata, config) {\r\n        const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME;\r\n        // this is needed to avoid a build error\r\n        if (metadata.level === NgxLoggerLevel.OFF) {\r\n            return undefined;\r\n        }\r\n        return configColorScheme[metadata.level];\r\n    }\r\n    /** Log to the console specifically for IE */\r\n    logIE(metadata, config, metaString) {\r\n        // Coloring doesn't work in IE\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`${metaString} `, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Log to the console */\r\n    logModern(metadata, config, metaString) {\r\n        const color = this.getColor(metadata, config);\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n            // the console.trace statement\r\n            // case NgxLoggerLevel.TRACE:\r\n            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n            //   break;\r\n            case NgxLoggerLevel.DEBUG:\r\n                console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Write the content sent to the log function to the console */\r\n    writeMessage(metadata, config) {\r\n        const metaString = this.prepareMetaString(metadata, config);\r\n        this.logFunc(metadata, config, metaString);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [PLATFORM_ID]\r\n                }] }]; } });\n\nclass NGXLogger {\r\n    constructor(config, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n        this.configEngine = configEngineFactory.provideConfigEngine(config);\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.configEngine.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.configEngine.serverLogLevel;\r\n    }\r\n    trace(message, ...additional) {\r\n        this._log(NgxLoggerLevel.TRACE, message, additional);\r\n    }\r\n    debug(message, ...additional) {\r\n        this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n    }\r\n    info(message, ...additional) {\r\n        this._log(NgxLoggerLevel.INFO, message, additional);\r\n    }\r\n    log(message, ...additional) {\r\n        this._log(NgxLoggerLevel.LOG, message, additional);\r\n    }\r\n    warn(message, ...additional) {\r\n        this._log(NgxLoggerLevel.WARN, message, additional);\r\n    }\r\n    error(message, ...additional) {\r\n        this._log(NgxLoggerLevel.ERROR, message, additional);\r\n    }\r\n    fatal(message, ...additional) {\r\n        this._log(NgxLoggerLevel.FATAL, message, additional);\r\n    }\r\n    /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomHttpHeaders(headers) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpHeaders = headers;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomParams(params) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpParams = params;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\r\n    setWithCredentialsOptionValue(withCredentials) {\r\n        const config = this.getConfigSnapshot();\r\n        config.withCredentials = withCredentials;\r\n        this.updateConfig(config);\r\n    }\r\n    /**\r\n     * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n     *\r\n     * There is only one monitor, registering one will overwrite the last one if there was one\r\n     * @param monitor\r\n     */\r\n    registerMonitor(monitor) {\r\n        this._loggerMonitor = monitor;\r\n    }\r\n    /** Set config of logger\r\n     *\r\n     * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n     */\r\n    updateConfig(config) {\r\n        this.configEngine.updateConfig(config);\r\n    }\r\n    partialUpdateConfig(partialConfig) {\r\n        this.configEngine.partialUpdateConfig(partialConfig);\r\n    }\r\n    /** Get config of logger */\r\n    getConfigSnapshot() {\r\n        return this.configEngine.getConfig();\r\n    }\r\n    /**\r\n     * Flush the serveur queue\r\n     */\r\n    flushServerQueue() {\r\n        this.serverService.flushQueue(this.getConfigSnapshot());\r\n    }\r\n    _log(level, message, additional = []) {\r\n        const config = this.configEngine.getConfig();\r\n        const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\r\n        const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\r\n        const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\r\n        if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\r\n            // If nothing is to be called we return\r\n            return;\r\n        }\r\n        const metadata = this.metadataService.getMetadata(level, config, message, additional);\r\n        this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\r\n            if (logPosition) {\r\n                metadata.fileName = logPosition.fileName;\r\n                metadata.lineNumber = logPosition.lineNumber;\r\n                metadata.columnNumber = logPosition.columnNumber;\r\n            }\r\n            if (shouldCallMonitor && this._loggerMonitor) {\r\n                this._loggerMonitor.onLog(metadata, config);\r\n            }\r\n            if (shouldCallWriter) {\r\n                this.writerService.writeMessage(metadata, config);\r\n            }\r\n            if (shouldCallServer) {\r\n                this.serverService.sendToServer(metadata, config);\r\n            }\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, deps: [{ token: TOKEN_LOGGER_CONFIG }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                }] }]; } });\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n */\r\nclass CustomNGXLoggerService {\r\n    constructor(logger, configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.logger = logger;\r\n        this.configEngineFactory = configEngineFactory;\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n    }\r\n    /**\r\n     * Create an instance of a logger\r\n     * @deprecated this function does not have all the features, @see getNewInstance for every params available\r\n     * @param config\r\n     * @param serverService\r\n     * @param logMonitor\r\n     * @param mapperService\r\n     * @returns\r\n     */\r\n    create(config, serverService, logMonitor, mapperService) {\r\n        return this.getNewInstance({\r\n            config,\r\n            serverService,\r\n            logMonitor,\r\n            mapperService\r\n        });\r\n    }\r\n    /**\r\n     * Get a new instance of NGXLogger\r\n     * @param params list of optional params to use when creating an instance of NGXLogger\r\n     * @returns the new instance of NGXLogger\r\n     */\r\n    getNewInstance(params) {\r\n        const logger = new NGXLogger(params?.config ?? this.logger.getConfigSnapshot(), params?.configEngineFactory ?? this.configEngineFactory, params?.metadataService ?? this.metadataService, params?.ruleService ?? this.ruleService, params?.mapperService ?? this.mapperService, params?.writerService ?? this.writerService, params?.serverService ?? this.serverService);\r\n        if (params?.partialConfig) {\r\n            logger.partialUpdateConfig(params.partialConfig);\r\n        }\r\n        if (params?.logMonitor) {\r\n            logger.registerMonitor(params.logMonitor);\r\n        }\r\n        return logger;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, deps: [{ token: NGXLogger }, { token: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: NGXLogger }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                }] }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                }] }]; } });\n\nclass LoggerModule {\r\n    static forRoot(config, customProvider) {\r\n        if (!customProvider) {\r\n            customProvider = {};\r\n        }\r\n        // default config provider\r\n        if (!customProvider.configProvider) {\r\n            customProvider.configProvider = { provide: TOKEN_LOGGER_CONFIG, useValue: config || {} };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\r\n                throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\r\n            }\r\n        }\r\n        // default configEngine provider\r\n        if (!customProvider.configEngineFactoryProvider) {\r\n            customProvider.configEngineFactoryProvider = { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactory };\r\n        }\r\n        else {\r\n            // if the user provided its own configEngineFactory, we just make sure the injection token is correct\r\n            if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\r\n                throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\r\n            }\r\n        }\r\n        // default metadata provider\r\n        if (!customProvider.metadataProvider) {\r\n            customProvider.metadataProvider = { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataService };\r\n        }\r\n        else {\r\n            // if the user provided its own metadataService, we just make sure the injection token is correct\r\n            if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\r\n                throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\r\n            }\r\n        }\r\n        // default rule provider\r\n        if (!customProvider.ruleProvider) {\r\n            customProvider.ruleProvider = { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesService };\r\n        }\r\n        else {\r\n            // if the user provided its own ruleService, we just make sure the injection token is correct\r\n            if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\r\n                throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\r\n            }\r\n        }\r\n        // default mapper provider\r\n        if (!customProvider.mapperProvider) {\r\n            customProvider.mapperProvider = { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperService };\r\n        }\r\n        else {\r\n            // if the user provided its own mapperService, we just make sure the injection token is correct\r\n            if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\r\n                throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\r\n            }\r\n        }\r\n        // default writer provider\r\n        if (!customProvider.writerProvider) {\r\n            customProvider.writerProvider = { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterService };\r\n        }\r\n        else {\r\n            // if the user provided its own writerService, we just make sure the injection token is correct\r\n            if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\r\n                throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        // default server provider\r\n        if (!customProvider.serverProvider) {\r\n            customProvider.serverProvider = { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerService };\r\n        }\r\n        else {\r\n            // if the user provided its own serverService, we just make sure the injection token is correct\r\n            if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\r\n                throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        return {\r\n            ngModule: LoggerModule,\r\n            providers: [\r\n                NGXLogger,\r\n                customProvider.configProvider,\r\n                customProvider.configEngineFactoryProvider,\r\n                customProvider.metadataProvider,\r\n                customProvider.ruleProvider,\r\n                customProvider.mapperProvider,\r\n                customProvider.writerProvider,\r\n                customProvider.serverProvider,\r\n                CustomNGXLoggerService,\r\n            ]\r\n        };\r\n    }\r\n    static forChild() {\r\n        // todo : this forChild is useless for now because nothing is different from forRoot.\r\n        // This should be implemented so that user can change the providers in the forChild\r\n        return {\r\n            ngModule: LoggerModule,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [CommonModule] });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [\r\n                        CommonModule\r\n                    ],\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerConfigEngineFactory, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}