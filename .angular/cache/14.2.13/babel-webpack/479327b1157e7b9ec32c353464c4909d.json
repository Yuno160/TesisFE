{"ast":null,"code":"import { EventEmitter, SimpleChanges } from '@angular/core'; // Añadimos Input, OnChanges, SimpleChanges\n\nimport { EMPTY, of } from 'rxjs'; // Añadimos 'of'\n\nimport { catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../core/services/cif-code.service\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"../tree-node/tree-node.component\";\n\nfunction CifTreeComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\")(1, \"app-tree-node\", 5);\n    i0.ɵɵlistener(\"nodeToggled\", function CifTreeComponent_ng_container_1_li_2_Template_app_tree_node_nodeToggled_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r6.onNodeToggle($event));\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const node_r5 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"node\", node_r5)(\"searchTerm\", ctx_r4.searchTerm);\n  }\n}\n\nfunction CifTreeComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ul\", 3);\n    i0.ɵɵtemplate(2, CifTreeComponent_ng_container_1_li_2_Template, 2, 2, \"li\", 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const nodes_r3 = ctx.ngIf;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", nodes_r3);\n  }\n}\n\nfunction CifTreeComponent_ng_template_3_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\")(1, \"p\", 7);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r8.errorMsg);\n  }\n}\n\nfunction CifTreeComponent_ng_template_3_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"p\");\n    i0.ɵɵtext(1, \"Cargando \\u00E1rbol...\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction CifTreeComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CifTreeComponent_ng_template_3_div_0_Template, 3, 1, \"div\", 1);\n    i0.ɵɵtemplate(1, CifTreeComponent_ng_template_3_ng_template_1_Template, 2, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n  }\n\n  if (rf & 2) {\n    const _r9 = i0.ɵɵreference(2);\n\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.errorMsg)(\"ngIfElse\", _r9);\n  }\n}\n\nexport class CifTreeComponent {\n  constructor(cifCodeService) {\n    this.cifCodeService = cifCodeService;\n    this.originalTree = []; // Guardamos el árbol completo sin filtrar\n\n    this.errorMsg = '';\n    this.searchTerm = ''; // Nuevo: Recibe el término de búsqueda\n\n    this.selectionUpdate = new EventEmitter();\n    this.selectedNodes = new Map();\n  }\n\n  ngOnInit() {\n    // Cargamos el árbol una sola vez\n    this.cifCodeService.getTree().pipe(catchError(err => {\n      this.errorMsg = 'Error al cargar los datos: ' + err.message;\n      return EMPTY;\n    })).subscribe(data => {\n      this.originalTree = data; // Guardamos la data original\n\n      this.applyFilter(); // Aplicamos el filtro inicial (vacío)\n    });\n  }\n\n  ngOnChanges(changes) {\n    // Si el searchTerm cambia, volvemos a aplicar el filtro\n    if (changes['searchTerm'] && !changes['searchTerm'].firstChange) {\n      this.applyFilter();\n    }\n  }\n\n  applyFilter() {\n    if (!this.searchTerm) {\n      this.filteredTree$ = of(this.originalTree); // Si no hay término, muestra todo\n\n      return;\n    }\n\n    const lowerCaseSearchTerm = this.searchTerm.toLowerCase(); // Función recursiva para filtrar el árbol\n\n    const filterNodes = nodes => {\n      return nodes.map(node => ({ ...node\n      })) // Copiamos el nodo para no mutar el original\n      .filter(node => {\n        const match = node.codigo.toLowerCase().includes(lowerCaseSearchTerm) || node.descripcion.toLowerCase().includes(lowerCaseSearchTerm);\n        const filteredChildren = filterNodes(node.children); // Filtra los hijos\n        // Un nodo coincide si:\n        // 1. Él mismo coincide, O\n        // 2. Alguno de sus hijos coincide (y lo mostramos expandido)\n\n        if (match || filteredChildren.length > 0) {\n          node.children = filteredChildren; // Asigna los hijos filtrados\n          // Aquí podríamos forzar isExpanded = true si el nodo original está oculto por filtro\n          // Lo manejaremos en TreeNode para la visibilidad.\n\n          return true;\n        }\n\n        return false;\n      });\n    };\n\n    this.filteredTree$ = of(filterNodes(this.originalTree));\n  }\n\n  onNodeToggle(event) {\n    // ... (este método no cambia)\n    if (event.checked) {\n      this.selectedNodes.set(event.node.codigo, event.node);\n    } else {\n      this.selectedNodes.delete(event.node.codigo);\n    }\n\n    const selectedList = Array.from(this.selectedNodes.values());\n    this.selectionUpdate.emit(selectedList);\n  }\n\n}\n\nCifTreeComponent.ɵfac = function CifTreeComponent_Factory(t) {\n  return new (t || CifTreeComponent)(i0.ɵɵdirectiveInject(i1.CifCodeService));\n};\n\nCifTreeComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: CifTreeComponent,\n  selectors: [[\"app-cif-tree\"]],\n  inputs: {\n    searchTerm: \"searchTerm\"\n  },\n  outputs: {\n    selectionUpdate: \"selectionUpdate\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature],\n  decls: 5,\n  vars: 4,\n  consts: [[1, \"tree-container\"], [4, \"ngIf\", \"ngIfElse\"], [\"loadingOrError\", \"\"], [1, \"tree-root\"], [4, \"ngFor\", \"ngForOf\"], [3, \"node\", \"searchTerm\", \"nodeToggled\"], [\"loading\", \"\"], [1, \"error\"]],\n  template: function CifTreeComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵtemplate(1, CifTreeComponent_ng_container_1_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵpipe(2, \"async\");\n      i0.ɵɵtemplate(3, CifTreeComponent_ng_template_3_Template, 3, 2, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      const _r1 = i0.ɵɵreference(4);\n\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(2, 2, ctx.filteredTree$))(\"ngIfElse\", _r1);\n    }\n  },\n  dependencies: [i2.NgForOf, i2.NgIf, i3.TreeNodeComponent, i2.AsyncPipe],\n  styles: [\"[_nghost-%COMP%]   ul.tree-root[_ngcontent-%COMP%] {\\r\\n  list-style-type: none; \\r\\n  padding-left: 0;       \\r\\n  margin: 0;\\r\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNpZi10cmVlLmNvbXBvbmVudC5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNENBQTRDOztBQUU1Qzs7Q0FFQzs7QUFDRDtFQUNFLHFCQUFxQixFQUFFLGtCQUFrQjtFQUN6QyxlQUFlLFFBQVEsdUNBQXVDO0VBQzlELFNBQVM7QUFDWCIsImZpbGUiOiJjaWYtdHJlZS5jb21wb25lbnQuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLyogc3JjL2FwcC9jaWYtdHJlZS9jaWYtdHJlZS5jb21wb25lbnQuY3NzICovXHJcblxyXG4vKiBVc2Ftb3MgOmhvc3QgcGFyYSBzZWxlY2Npb25hciBzb2xvIGxvcyA8dWw+IFxyXG4gIHF1ZSBlc3TDoW4gZGlyZWN0YW1lbnRlIGVuIGVzdGUgY29tcG9uZW50ZS4gXHJcbiovXHJcbjpob3N0IHVsLnRyZWUtcm9vdCB7XHJcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lOyAvKiDCoVNpbiBidWxsZXRzISAqL1xyXG4gIHBhZGRpbmctbGVmdDogMDsgICAgICAgLyogU2luIGluZGVudGFjacOzbiBwYXJhIGVsIG5pdmVsIHJhw616ICovXHJcbiAgbWFyZ2luOiAwO1xyXG59Il19 */\"]\n});","map":{"version":3,"mappings":"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","names":["EventEmitter","SimpleChanges","EMPTY","of","catchError","i0","ctx_r4","_r9","CifTreeComponent","constructor","cifCodeService","Map","ngOnInit","getTree","pipe","err","errorMsg","message","subscribe","data","originalTree","applyFilter","ngOnChanges","changes","firstChange","searchTerm","filteredTree$","lowerCaseSearchTerm","toLowerCase","filterNodes","nodes","map","node","filter","match","codigo","includes","descripcion","filteredChildren","children","length","onNodeToggle","event","checked","selectedNodes","set","delete","selectedList","Array","from","values","selectionUpdate","emit","selectors","inputs","outputs","features","decls","vars","consts","template","_r1"],"sourceRoot":"","sources":["D:\\Nueva carpeta\\Shogai-internal\\ultimoAhoraSi\\src\\app\\features\\cif-tree\\cif-tree.component.ts","D:\\Nueva carpeta\\Shogai-internal\\ultimoAhoraSi\\src\\app\\features\\cif-tree\\cif-tree.component.html"],"sourcesContent":["\nimport { Component, OnInit, Output, EventEmitter, Input, OnChanges, SimpleChanges } from '@angular/core'; // Añadimos Input, OnChanges, SimpleChanges\nimport { Observable, EMPTY, of } from 'rxjs'; // Añadimos 'of'\nimport { catchError, map } from 'rxjs/operators';\nimport { CifNode } from '../../core/models/Cif-code';\nimport { CifCodeService } from '../../core/services/cif-code.service';\nimport { NodeToggleEvent } from '../../core/models/Cif-code'; // Importamos la interfaz\n\n\n@Component({\n  selector: 'app-cif-tree',\n  templateUrl: './cif-tree.component.html',\n  styleUrls: ['./cif-tree.component.css']\n})\nexport class CifTreeComponent implements OnInit, OnChanges { // Implementamos OnChanges\n\n  public originalTree: CifNode[] = []; // Guardamos el árbol completo sin filtrar\n  public filteredTree$: Observable<CifNode[]>; // El árbol que se muestra (filtrado)\n  public errorMsg: string = '';\n\n  @Input() searchTerm: string = ''; // Nuevo: Recibe el término de búsqueda\n\n  @Output() selectionUpdate = new EventEmitter<CifNode[]>(); \n\n  private selectedNodes = new Map<string, CifNode>();\n\n  constructor(private cifCodeService: CifCodeService) { }\n\n  ngOnInit(): void {\n    // Cargamos el árbol una sola vez\n    this.cifCodeService.getTree().pipe(\n      catchError(err => {\n        this.errorMsg = 'Error al cargar los datos: ' + err.message;\n        return EMPTY;\n      })\n    ).subscribe(data => {\n      this.originalTree = data; // Guardamos la data original\n      this.applyFilter(); // Aplicamos el filtro inicial (vacío)\n    });\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    // Si el searchTerm cambia, volvemos a aplicar el filtro\n    if (changes['searchTerm'] && !changes['searchTerm'].firstChange) {\n      this.applyFilter();\n    }\n  }\n\n  private applyFilter(): void {\n    if (!this.searchTerm) {\n      this.filteredTree$ = of(this.originalTree); // Si no hay término, muestra todo\n      return;\n    }\n\n    const lowerCaseSearchTerm = this.searchTerm.toLowerCase();\n    \n    // Función recursiva para filtrar el árbol\n    const filterNodes = (nodes: CifNode[]): CifNode[] => {\n      return nodes\n        .map(node => ({ ...node })) // Copiamos el nodo para no mutar el original\n        .filter(node => {\n          const match = \n            node.codigo.toLowerCase().includes(lowerCaseSearchTerm) ||\n            node.descripcion.toLowerCase().includes(lowerCaseSearchTerm);\n\n          const filteredChildren = filterNodes(node.children); // Filtra los hijos\n          \n          // Un nodo coincide si:\n          // 1. Él mismo coincide, O\n          // 2. Alguno de sus hijos coincide (y lo mostramos expandido)\n          if (match || filteredChildren.length > 0) {\n            node.children = filteredChildren; // Asigna los hijos filtrados\n            // Aquí podríamos forzar isExpanded = true si el nodo original está oculto por filtro\n            // Lo manejaremos en TreeNode para la visibilidad.\n            return true;\n          }\n          return false;\n        });\n    };\n\n    this.filteredTree$ = of(filterNodes(this.originalTree));\n  }\n\n\n  public onNodeToggle(event: NodeToggleEvent): void {\n    // ... (este método no cambia)\n    if (event.checked) {\n      this.selectedNodes.set(event.node.codigo, event.node);\n    } else {\n      this.selectedNodes.delete(event.node.codigo);\n    }\n\n    const selectedList = Array.from(this.selectedNodes.values());\n    this.selectionUpdate.emit(selectedList);\n  }\n}","<div class=\"tree-container\">\n  \n  <ng-container *ngIf=\"filteredTree$ | async as nodes; else loadingOrError\"> <ul class=\"tree-root\">\n      <li *ngFor=\"let node of nodes\">\n        <app-tree-node \n          [node]=\"node\"\n          (nodeToggled)=\"onNodeToggle($event)\"\n          [searchTerm]=\"searchTerm\" >\n        </app-tree-node>\n      </li>\n    </ul>\n\n  </ng-container>\n\n  <ng-template #loadingOrError>\n    <div *ngIf=\"errorMsg; else loading\">\n      <p class=\"error\">{{ errorMsg }}</p>\n    </div>\n    <ng-template #loading>\n      <p>Cargando árbol...</p>\n    </ng-template>\n  </ng-template>\n\n</div>"]},"metadata":{},"sourceType":"module"}